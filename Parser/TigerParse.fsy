%{

(* Parser specification for Tiger Language *)

open Tokens

// Helper functions could be defined here

%}

%token <int> INT
%token <string> STRING
%token <string> ID

%token ARRAY BREAK DO ELSE END FOR
%token FUNCTION IF IN LET NIL OF
%token THEN TO TYPE VAR WHILE

%token ASSIGN DOT LPAREN RPAREN LBRACK RBRACK
%token LBRACE RBRACE SEMICOLON COLON COMMA

%token AND OR TIMES DIVIDE PLUS MINUS
%token EQ NEQ GT GE LT LE

%token EOF

/* Precedence */

%right ASSIGN
%left OR
%left AND
%nonassoc EQ NEQ GT GE LT LE
%left PLUS MINUS
%left TIMES DIVIDE
%nonassoc Negation
%nonassoc LBRACK

/* Start symbol and its type */

%start Main
%type <unit> Main

%%

Main:
    Exp EOF            { printfn "Main: Exp" }
;

/* Expression */

Exp:
    | INT              { () }
    | STRING           { () }
    | NIL              { () }
    | BREAK            { () }

    | LValue           { () }
    | Negation         { () }
    | InfixOp          { () }
    | Assign           { () }
    | FunCall          { () }
    | RecCreate        { () }
    | ArrCreate        { () }
    | SeqExp           { () }
    | IfExp            { () }
    | WhileExp         { () }
    | ForExp           { () }
    | LetExp           { () }
;

LValue:
    | ID                          { () }
    | LValue DOT ID               { () }
    | LValue LBRACK Exp RBRACK    { () }
;

Negation:
    | MINUS Exp             { () }
;

InfixOp:
    | Exp Op Exp            { () }
;

Assign:
    | LValue ASSIGN Exp     { () }
;

FunCall:
    | ID LPAREN ActualParams RPAREN    { () }
;

ActualParams:
    | /* empty */          { () }
    | ExpList              { () }

ExpList:
    | Exp                  { () }
    | ExpList COMMA Exp    { () }

RecCreate:
    | ID LBRACE RecAggregate RBRACE   { () }
;

ArrCreate:
    | ID LBRACK Exp RBRACK OF Exp     { () }
;

RecAggregate:
    | /* empty */          { () }
    | FieldList            { () }
;

FieldList:
    | ID ASSIGN Exp                   { () }
    | FieldList COMMA ID ASSIGN Exp   { () }
;

SeqExp:
    | LPAREN TwoOrMoreExp RPAREN      { () }
;

TwoOrMoreExp:
    | Exp SEMICOLON Exp               { () }
    | TwoOrMoreExp SEMICOLON ExpSeq   { () }
;

ExpSeq:
    | Exp                             { () }
    | ExpSeq SEMICOLON Exp            { () }
;

IfExp:
    | IF Exp THEN Exp                 { () }
    | IF Exp THEN Exp ELSE Exp        { () }
;

WhileExp:
    | WHILE Exp DO Exp  { () }
;

ForExp:
    | FOR ID ASSIGN Exp TO Exp DO Exp { () }
;

LetExp:
    | LET Declarations IN Stmts END   { () }
;

Declarations:
    | /* empty */           { () }
    | DecList               { () }
;

DecList:
    | Dec                   { () }
    | DecList Dec           { () }
;

Stmts:
    | /* empty */           { () }
    | ExpSeq                { () }

Dec:
    | TyDec                 { () }
    | VarDec                { () }
    | FunDec                { () }
;

TyDec:
    | TYPE ID EQ Ty         { () }
;

VarDec:
    | VAR ID ASSIGN Exp                    { () }
    | VAR ID COLON ID ASSIGN Exp           { () }
;

FunDec:
    | FUNCTION ID LPAREN FieldDec RPAREN EQ Exp            { () }
    | FUNCTION ID LPAREN FieldDec RPAREN COLON ID EQ Exp   { () }
;

/* Data types */

Ty:
    | ID                                   { () }
    | LBRACE FieldDec RBRACE               { () }
    | ARRAY OF ID                          { () }
;

FieldDec:
    | /* empty */                          { () }
    | TypeFieldList                        { () }
;

TypeFieldList:
    | ID COLON ID                          { () }
    | TypeFieldList COMMA ID COLON ID      { () }
;

Op:
    | PLUS                  { () }
    | MINUS                 { () }
    | TIMES                 { () }
    | DIVIDE                { () }
    | EQ                    { () }
    | NEQ                   { () }
    | GT                    { () }
    | GE                    { () }
    | LT                    { () }
    | LE                    { () }
;
